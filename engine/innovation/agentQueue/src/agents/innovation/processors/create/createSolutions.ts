import { BaseProcessor } from "../baseProcessor.js";
import { ChatOpenAI } from "langchain/chat_models/openai";
import { HumanChatMessage, SystemChatMessage } from "langchain/schema";

import { IEngineConstants } from "../../../../constants.js";
import { WebPageVectorStore } from "../../vectorstore/webPage.js";

export class CreateSolutionsProcessor extends BaseProcessor {
  webPageVectorStore = new WebPageVectorStore();

  async renderRefinePrompt(
    results: IEngineSolution[],
    generalTextContext: string,
    scientificTextContext: string,
    openDataTextContext: string,
    newsTextContext: string,
    subProblemIndex: number,
    alreadyCreatedSolutions: string | undefined = undefined
  ) {
    const messages = [
      new SystemChatMessage(
        `
        You are an expert trained to analyse complex problem statements and sub-problems to refine innovative solutions for solutions to those problems.

        Adhere to the following guidelines:
        1. Review all the solutions previously generated by you and others and refine then, do not create new solutions.
        2. Solutions should be practical, thoughtful, innovative, equitable and succinct.
        3. Solution descriptions should be at most six sentences long.
        4. Do not created the same solutions if listed under Already created solutions
        5. If entities are mentioned, they should be the ones affected by the solutions.
        6 Use context given to inform and inspire your solutions for solutions.
        7. Never refer to the context given as the user won't see it.
        8. Never output in markdown format.
        9. For the main problem and all sub-problems, generate the search queries, provide an output in the following JSON format:
          [ { title, description, howCanSolutionHelp } ].
        10. Ensure a methodical, step-by-step approach to create the best possible solutions.
        `
      ),
      new HumanChatMessage(
        `
        ${this.renderPromblemsWithIndexAndEntities(subProblemIndex)}

        ${
          alreadyCreatedSolutions
            ? `
          Already created solutions:
          ${alreadyCreatedSolutions}
        `
            : ``
        }

        Previous New Solutions JSON Output To Review and Refine:
        ${JSON.stringify(results, null, 2)}

        New Refined New Solutions JSON Output:
       `
      ),
    ];

    return messages;
  }

  renderCreateSystemMessage() {
    return new SystemChatMessage(
      `
      You are an expert trained to analyse complex problem statements and sub-problems to create new innovative solutions for solutions to those problems.

      Adhere to the following guidelines:
      1. Solutions should be practical, thoughtful, innovative, equitable and succinct.
      2. Output seven solutions in JSON format
      3. You should write out a short title, description, and how it can help.
      4. Solution descriptions should be at most five sentences long.
      5. Do not created the same solutions if listed under Already created solutions
      6. If entities are mentioned, they should be the ones affected by the solutions.
      7. Use context given to inform and inspire your solutions for solutions.
      8. Never refer to the context given as the user won't see it.
      9. Never output in markdown format.
      10. For the main problem and all sub-problems, generate the search queries, provide an output in the following JSON format:
        [ { title, description, howCanSolutionHelp } ].
      11. Ensure a methodical, step-by-step approach to create the best possible solutions.
      `
    );
  }

  renderCreateForTestTokens(
    subProblemIndex: number,
    alreadyCreatedSolutions: string | undefined = undefined
  ) {
    const messages = [
      this.renderCreateSystemMessage(),
      new HumanChatMessage(
        `
        ${this.renderPromblemsWithIndexAndEntities(subProblemIndex)}

        Possible general context for solutions:

        Possible scientific context for solutions:

        Possible open data context for solutions:

        Possible news context for solutions:

        ${
          alreadyCreatedSolutions
            ? `
          Already created solutions:
          ${alreadyCreatedSolutions}
        `
            : ``
        }

        Solutions JSON Output:
       `
      ),
    ];

    return messages;
  }

  async renderCreatePrompt(
    generalTextContext: string,
    scientificTextContext: string,
    openDataTextContext: string,
    newsTextContext: string,
    subProblemIndex: number,
    alreadyCreatedSolutions: string | undefined = undefined
  ) {
    const messages = [
      this.renderCreateSystemMessage(),
      new HumanChatMessage(
        `
        ${this.renderPromblemsWithIndexAndEntities(subProblemIndex)}

        Possible general context for solutions:
        ${generalTextContext}

        Possible scientific context for solutions:
        ${scientificTextContext}

        Possible open data context for solutions:
        ${openDataTextContext}

        Possible news context for solutions:
        ${newsTextContext}

        ${
          alreadyCreatedSolutions
            ? `
          Already created solutions:
          ${alreadyCreatedSolutions}
        `
            : ``
        }

        JSON Output:
       `
      ),
    ];

    return messages;
  }

  async createSolutions(
    subProblemIndex: number,
    generalTextContext: string,
    scientificTextContext: string,
    openDataTextContext: string,
    newsTextContext: string,
    alreadyCreatedSolutions: string | undefined = undefined
  ) {
    let results = await this.callLLM(
      "create-seed-solutions",
      IEngineConstants.createSeedSolutionsModel,
      await this.renderCreatePrompt(
        generalTextContext,
        scientificTextContext,
        openDataTextContext,
        newsTextContext,
        subProblemIndex,
        alreadyCreatedSolutions
      )
    );

    if (IEngineConstants.enable.refine.createSolutions) {
      results = await this.callLLM(
        "create-seed-solutions",
        IEngineConstants.createSeedSolutionsModel,
        await this.renderRefinePrompt(
          results,
          generalTextContext,
          scientificTextContext,
          openDataTextContext,
          newsTextContext,
          subProblemIndex,
          alreadyCreatedSolutions
        )
      );
    }

    return results;
  }

  randomSearchQueryIndex(subProblemIndex: number | undefined) {
    const randomIndex = Math.min(
      Math.floor(
        Math.random() *
          (IEngineConstants.maxTopSearchQueriesForSolutionCreation + 1)
      ),
      subProblemIndex
        ? this.memory.subProblems[subProblemIndex].searchQueries.general
            .length - 1
        : 2
    );
    if (
      Math.random() <
      IEngineConstants.chances.notUsingFirstSearchQueryForNewSolutions
    ) {
      return randomIndex;
    } else {
      return 0;
    }
  }

  getAllTypeQueries(
    searchQueries: IEngineSearchQueries,
    subProblemIndex: number | undefined
  ) {
    return {
      general:
        searchQueries.general[this.randomSearchQueryIndex(subProblemIndex)],
      scientific:
        searchQueries.scientific[this.randomSearchQueryIndex(subProblemIndex)],
      openData:
        searchQueries.openData[this.randomSearchQueryIndex(subProblemIndex)],
      news: searchQueries.news[this.randomSearchQueryIndex(subProblemIndex)],
    };
  }

  getRandomSearchQueryForType(
    type: IEngineWebPageTypes,
    problemStatementQueries: IEngineSearchQuery,
    subProblemQueries: IEngineSearchQuery,
    otherSubProblemQueries: IEngineSearchQuery
  ) {
    let random = Math.random();

    let selectedQuery: string;

    if (random < IEngineConstants.chances.useMainProblemSearchQueriesNewSolutions) {
      selectedQuery = problemStatementQueries[type];
    } else if (
      random <
      IEngineConstants.chances.useOtherSubProblemSearchQueriesNewSolutions +
        IEngineConstants.chances.useMainProblemSearchQueriesNewSolutions
    ) {
      selectedQuery = otherSubProblemQueries[type];
    } else {
      selectedQuery = subProblemQueries[type];
    }

    return selectedQuery;
  }

  getSearchQueries(subProblemIndex: number) {
    const otherSubProblemIndexes = [];

    for (let i = 0; i < this.memory.subProblems.length; i++) {
      if (i != subProblemIndex) {
        otherSubProblemIndexes.push(i);
      }
    }

    const randomSubProblemIndex =
      otherSubProblemIndexes[
        Math.floor(Math.random() * otherSubProblemIndexes.length)
      ];

    const problemStatementQueries = this.getAllTypeQueries(
      this.memory.problemStatement.searchQueries,
      undefined
    );

    const subProblemQueries = this.getAllTypeQueries(
      this.memory.subProblems[subProblemIndex].searchQueries,
      subProblemIndex
    );

    const otherSubProblemQueries = this.getAllTypeQueries(
      this.memory.subProblems[randomSubProblemIndex].searchQueries,
      randomSubProblemIndex
    );

    //TODO: Refactor the types to be an array ["scientific", "general", ...]
    let scientific = this.getRandomSearchQueryForType(
      "scientific",
      problemStatementQueries,
      subProblemQueries,
      otherSubProblemQueries
    );

    let general = this.getRandomSearchQueryForType(
      "general",
      problemStatementQueries,
      subProblemQueries,
      otherSubProblemQueries
    );

    let openData = this.getRandomSearchQueryForType(
      "openData",
      problemStatementQueries,
      subProblemQueries,
      otherSubProblemQueries
    );

    let news = this.getRandomSearchQueryForType(
      "news",
      problemStatementQueries,
      subProblemQueries,
      otherSubProblemQueries
    );

    return {
      scientific,
      general,
      openData,
      news,
    };
  }

  async getTextContext(
    subProblemIndex: number,
    alreadyCreatedSolutions: string | undefined = undefined
  ) {
    const selectedSearchQueries = this.getSearchQueries(subProblemIndex);

    return {
      general: await this.getSearchQueryTextContext(
        subProblemIndex,
        selectedSearchQueries["general"],
        "general",
        alreadyCreatedSolutions
      ),
      scientific: await this.getSearchQueryTextContext(
        subProblemIndex,
        selectedSearchQueries["scientific"],
        "scientific",
        alreadyCreatedSolutions
      ),
      openData: await this.getSearchQueryTextContext(
        subProblemIndex,
        selectedSearchQueries["openData"],
        "openData",
        alreadyCreatedSolutions
      ),
      news: await this.getSearchQueryTextContext(
        subProblemIndex,
        selectedSearchQueries["news"],
        "news",
        alreadyCreatedSolutions
      ),
    };
  }

  async countTokensForString(text: string) {
    const tokenCountData = await this.chat!.getNumTokensFromMessages([
      new HumanChatMessage(text),
    ]);
    return tokenCountData.totalCount;
  }

  //TODO: Figure out the closest allRelevantParagraphs from Weaviate
  renderRawSearchResults(rawSearchResults: IEngineWebPageGraphQlResults) {
    const results = rawSearchResults.data.Get.WebPage;
    let searchResults = `
      ${results.summary}

      ${results.relevanceToProblem}

      ${results.possibleSolutionsToProblem.join("\n")}

      ${results.allRelevantParagraphs.join("\n")}
    `;

    return searchResults;
  }

  async searchForType(
    subProblemIndex: number,
    type: IEngineWebPageTypes,
    searchQuery: string,
    tokensLeftForType: number
  ) {
    let rawSearchResults: IEngineWebPageGraphQlResults;

    const random = Math.random();

    if (random < IEngineConstants.chances.useMainProblemVectorSearchNewSolutions) {
      rawSearchResults = await this.webPageVectorStore.searchWebPages(
        searchQuery,
        this.memory.groupId,
        undefined,
        type
      );
    } else {
      rawSearchResults = await this.webPageVectorStore.searchWebPages(
        searchQuery,
        this.memory.groupId,
        subProblemIndex,
        type
      );
    }

    let searchResults = this.renderRawSearchResults(rawSearchResults);

    while (
      (await this.countTokensForString(searchResults)) > tokensLeftForType
    ) {
      let sentences = searchResults.split(". ");
      sentences.pop();
      searchResults = sentences.join(". ");
    }

    return searchResults;
  }

  async getSearchQueryTextContext(
    subProblemIndex: number,
    searchQuery: string,
    type: IEngineWebPageTypes,
    alreadyCreatedSolutions: string | undefined = undefined
  ) {
    const tokenCountData = await this.chat!.getNumTokensFromMessages(
      this.renderCreateForTestTokens(subProblemIndex, alreadyCreatedSolutions)
    );
    const currentTokens = tokenCountData.totalCount;
    const tokensLeft =
      IEngineConstants.createSeedSolutionsModel.tokenLimit -
      (currentTokens + IEngineConstants.createSeedSolutionsModel.maxOutputTokens);
    const tokensLeftForType = Math.floor(
      tokensLeft / IEngineConstants.numberOfSearchTypes
    );
    this.logger.debug(
      `Tokens left for type: ${tokensLeftForType} for type ${type}`
    );

    return await this.searchForType(
      subProblemIndex,
      type,
      searchQuery,
      tokensLeftForType
    );
  }

  async createAllSolutions() {
    for (
      let subProblemIndex = 0;
      subProblemIndex <
      Math.min(this.memory.subProblems.length, IEngineConstants.maxSubProblems);
      subProblemIndex++
    ) {
      let solutions: IEngineSolution[] = [];

      // Create 28 solutions 7*4
      for (let i = 0; i < 4; i++) {
        let alreadyCreatedSolutions;

        if (i > 0) {
          alreadyCreatedSolutions = solutions
            .map((solution) => solution.title)
            .join("\n");
        }

        const textContexts = await this.getTextContext(
          subProblemIndex,
          alreadyCreatedSolutions
        );

        const newSolutions = await this.createSolutions(
          i,
          textContexts.general,
          textContexts.scientific,
          textContexts.openData,
          textContexts.news,
          alreadyCreatedSolutions
        );
        solutions = solutions.concat(newSolutions);
      }

      this.memory.subProblems[subProblemIndex].solutions.seed = solutions;

      await this.saveMemory();
    }
  }

  async process() {
    this.logger.info("Create Seed Solutions Processor");
    super.process();

    this.chat = new ChatOpenAI({
      temperature: IEngineConstants.createSearchQueriesModel.temperature,
      maxTokens: IEngineConstants.createSearchQueriesModel.maxOutputTokens,
      modelName: IEngineConstants.createSearchQueriesModel.name,
      verbose: IEngineConstants.createSearchQueriesModel.verbose,
    });

    await this.createAllSolutions();
  }
}
